################################################################################
## Copyright (C) 2022 Potsdam Institute for Climate Impact Research (PIK),    ##
## see COPYRIGHT file.                                                        ##
##                                                                            ##
## This file is part of LandInG and licensed under GNU AGPL Version 3 or      ##
## later. See LICENSE file or go to http://www.gnu.org/licenses/              ##
## Contact: https://github.com/PIK-LPJmL/LandInG/                             ##
################################################################################

################################################################################
## Script to do analysis of generated land use inputs for documentation paper ##
################################################################################

rm(list=ls())

################################################################################
## Basic setup of aggregation (following cft_input_timeseries.R)              ##
## (Optional) name of crop aggregation                                        ##
aggregation_name <- "default"
################################################################################

################################################################################
## Setup of variables valid across all scripts related to land use data       ##
## processing.                                                                ##
## - sets many directories and file names                                     ##
## - also loads several helper functions used by various land use processing  ##
##   scripts                                                                  ##
source("landuse_setup.R")
################################################################################

################################################################################
## Setup of bands in CFT input file (following cft_input_timeseries.R)        ##
## This needs to conform to CFTs, others, managed grasslands and bioenergy    ##
## plantation types defined in LPJmL.                                         ##
## Order must be identical to the one expected by LPJmL.                      ##
## LPJmL expects the same number of rainfed and irrigated bands.              ##
cft_bands <- c(
  "rainfed temperate cereals",
  "rainfed rice",
  "rainfed maize",
  "rainfed tropical cereals",
  "rainfed pulses",
  "rainfed temperate roots",
  "rainfed tropical roots",
  "rainfed oil crops sunflower",
  "rainfed oil crops soybean",
  "rainfed oil crops groundnut",
  "rainfed oil crops rapeseed",
  "rainfed sugar cane",
  "rainfed other crops",
  "rainfed pasture/managed grass",
  "rainfed bio-energy grass",
  "rainfed bio-energy tree",
  "irrigated temperate cereals",
  "irrigated rice",
  "irrigated maize",
  "irrigated tropical cereals",
  "irrigated pulses",
  "irrigated temperate roots",
  "irrigated tropical roots",
  "irrigated oil crops sunflower",
  "irrigated oil crops soybean",
  "irrigated oil crops groundnut",
  "irrigated oil crops rapeseed",
  "irrigated sugar cane",
  "irrigated other crops",
  "irrigated pasture/managed grass",
  "irrigated bio-energy grass",
  "irrigated bio-energy tree"
)
## Period for LPJmL file created (default: same as output_period)             ##
cft_output_period <- output_period
## Period for LPJmL file created (default: same as output_period)             ##
cft_output_period <- output_period
## Years to compare                                                           ##
comparison_years <- c(2000, 2015)
## Spatial unit to use for comparison table                                   ##
comparison_unit <- "km2"
## Optional version string (to distinguish between growing areas and          ##
## harvested areas)                                                           ##
version_string <- c(default = "", harvested = "ha_unscaled")
## Units used in CFT files (depending on version_string)                      ##
version_unit <- c(default = "", harvested = "ha")
## Grid file in LPJmL input format to use (such as a grid file generated by   ##
## the scripts in ../gadm)                                                    ##
# Analyse inputs for both grid files generated in sample application.
cft_gridname <- c(
  "../gadm_paper/grid_gadm_5arcmin.bin",
  "../gadm_paper/grid_gadm_30arcmin_predefined_grid.bin"
)
## Filename base for generated LPJmL input files (spatial resolution and      ##
## optional version strings added automatically). Define only output          ##
## directory (if desired) and first part of filename here. By default saved   ##
## to landuse_dir.                                                            ##
cft_output_filename_base <- c(default = "cft_", harvested = "ha_")
## Filename base for generated separate file containing fallow land           ##
# Not applicable for version "harvested"
cft_fallow_filename_base <- c(default = "cft_fallow_", harvested = "")
## Add optional aggregation name and optional version strings                 ##
if (nchar(aggregation_name) > 0) {
  bak_names <- names(cft_output_filename_base)
  cft_output_filename_base <- paste0(
    cft_output_filename_base,
    aggregation_name,
    "_cft_aggregation"
  )
  names(cft_output_filename_base) <- bak_names
  bak_names <- names(cft_fallow_filename_base)
  cft_fallow_filename_base <- paste0(
    cft_fallow_filename_base,
    aggregation_name,
    "_cft_aggregation"
  )
  names(cft_fallow_filename_base) <- bak_names
  rm(bak_names)
}
# Concatenate all possible version strings
file_version_string <- paste0(
  ifelse(
    exists("aquastat_version_string") && nchar(aquastat_version_string) > 0,
    paste0("_", aquastat_version_string),
    ""
  ),
  ifelse(
    exists("fao_version_string") && nchar(fao_version_string) > 0,
    paste0("_", fao_version_string),
    ""
  ),
  ifelse(
    exists("gadm_version_string") && nchar(gadm_version_string) > 0,
    paste0("_", gadm_version_string),
    ""
  ),
  ifelse(
    exists("gaez_version_string") && nchar(gaez_version_string) > 0,
    paste0("_", gaez_version_string),
    ""
  ),
  ifelse(
    exists("hyde_version_string") && nchar(hyde_version_string) > 0,
    paste0("_", hyde_version_string),
    ""
  ),
  ifelse(
    exists("mirca_version_string") && nchar(mirca_version_string) > 0,
    paste0("_", mirca_version_string),
    ""
  ),
  ifelse(
    exists("monfreda_version_string") && nchar(monfreda_version_string) > 0,
    paste0("_", monfreda_version_string),
    ""
  ),
  ifelse(
    exists("ramankutty_version_string") && nchar(ramankutty_version_string) > 0,
    paste0("_", ramankutty_version_string),
    ""
  )
)
bak_names <- names(cft_output_filename_base)
cft_output_filename_base <- paste0(
  cft_output_filename_base,
  file_version_string,
  "_"
)
names(cft_output_filename_base) <- bak_names
bak_names <- names(cft_fallow_filename_base)
cft_fallow_filename_base <- paste0(
  cft_fallow_filename_base,
  file_version_string,
  "_"
)
names(cft_fallow_filename_base) <- bak_names
rm(bak_names)
## Determine rainfed and irrigated crop bands in cft_bands                    ##
rf_crops <- intersect(
  grep("rainfed", cft_bands),
  grep("bio-energy|pasture", cft_bands, invert = TRUE)
)
ir_crops <- intersect(
  grep("irrigated", cft_bands),
  grep("bio-energy|pasture", cft_bands, invert = TRUE)
)
## ISIMIP2b landuse dataset                                                   ##
lufilename_isimip <- file.path(
  "/p", "projects", "ikiimp", "ISIMIP2b", "input_CLM2",
  "cftfrac_fullhist_1700-2015_32bands.clm"
)
## Units used in ISIMIP2b land use input                                      ##
luunit_isimip <- ""
################################################################################


################################################################################
## Load grid data and derive grid resolutions and areas                       ##
cft_gridheader <- list()
cft_griddata <- list()
cft_gridarea <- list()
for (i in seq_along(cft_gridname)) {
  tmp_header <- read_header(cft_gridname[i])
  # Determine resolution string
  tmp_res <- unique(
    ifelse(
      tmp_header$header[c("cellsize_lon", "cellsize_lat")] >= 1/60, 60, 3600
    ) * tmp_header$header[c("cellsize_lon", "cellsize_lat")]
  )
  tmp_string <- paste(
    round(tmp_res),
    unique(
      ifelse(
        tmp_header$header[c("cellsize_lon", "cellsize_lat")] >= 1/60,
        "min",
        "sec"
      )
    ),
    sep = "", collapse = "_by_"
  )
  cft_gridheader[[tmp_string]] <- tmp_header
  names(cft_gridname)[i] <- tmp_string
  zz <- file(cft_gridname[i], "rb")
  seek(zz, get_headersize(tmp_header))
  tmp_data <- matrix(
    readBin(
      zz,
      what = get_datatype(tmp_header)$type,
      size = get_datatype(tmp_header)$size,
      n = tmp_header$header["ncell"] * tmp_header$header["nbands"],
      endian = tmp_header$endian
    ) * tmp_header$header["scalar"],
    ncol = tmp_header$header["nbands"],
    byrow = tmp_header$header["order"] != 4
  )
  close(zz)
  cft_griddata[[tmp_string]] <- tmp_data
  cft_gridarea[[tmp_string]] <- cellarea(
    tmp_data[, 2],
    tmp_header$header["cellsize_lon"],
    tmp_header$header["cellsize_lat"]
  )
}
################################################################################


################################################################################
## Load growing areas and harvested areas for comparison_years                ##
# Load data for comparison_years
comparison_years <- unique(sort(comparison_years))
for (resol in names(cft_gridheader)) {
  for (version in names(version_string)) {
    cft_output_filename <- paste0(
      cft_output_filename_base[version],
      resol, "_", paste(range(cft_output_period), collapse = "-"),
      ".bin"
    )
    if (file.exists(cft_output_filename)) {
      cat("Load data from", cft_output_filename, "for year(s)",
          toString(comparison_years), "\n")
      tmp_header <- read_header(cft_output_filename)
      if (length(cft_bands) != tmp_header$header["nbands"]) {
        stop("Wrong number of bands in ", sQuote(cft_output_filename))
      }
      zz <- file(cft_output_filename, "rb")
      cmp_data <- array(
        dim = c(tmp_header$header[c("ncell", "nbands")],
                length(comparison_years)),
        dimnames = list(NULL, cft_bands, comparison_years)
      )
      for (y in seq_along(comparison_years)) {
        seek(
          zz,
          where = (comparison_years[y] - tmp_header$header["firstyear"]) *
            prod(tmp_header$header[c("ncell", "nbands")]) *
            get_datatype(tmp_header)$size + get_headersize(tmp_header)
        )
        cmp_data[, , y] <- matrix(
          readBin(
            zz,
            what = get_datatype(tmp_header)$type,
            size = get_datatype(tmp_header)$size,
            n = tmp_header$header["ncell"] * tmp_header$header["nbands"],
            endian = tmp_header$endian
          ) * tmp_header$header["scalar"],
          ncol = tmp_header$header["nbands"],
          byrow = tmp_header$header["order"] != 4
        )
      }
      varname <- paste0("ludata_", resol)
      if(nchar(version_string[version]) > 0) {
        varname <- paste0(varname, "_", version_string[version])
      }
      if (!ud.are.convertible(version_unit[version], "m2")) {
        # Assume fractional and convert into area
        cmp_data <- ud.convert(cmp_data, version_unit[version], 1) *
          cft_gridarea[[resol]]
        # Data is now in m2.
      }
      assign(varname, cmp_data)
      close(zz)
      # Fallow land
      cft_output_filename <- sub(
        paste0("^", cft_output_filename_base[version]),
        cft_fallow_filename_base[version],
        basename(cft_output_filename)
      )
      if (file.exists(cft_output_filename)) {
        cat("Load data from", cft_output_filename, "\n")
        tmp_header <- read_header(cft_output_filename)
        if (tmp_header$header["nbands"] != 2) {
          stop("Wrong number of bands in ", sQuote(cft_output_filename))
        }
        zz <- file(cft_output_filename, "rb")
        cmp_data <- array(
          dim = c(tmp_header$header[c("ncell", "nbands")],
                  length(comparison_years)),
          dimnames = list(
            NULL,
            paste(c("rainfed", "irrigated"), "fallow"),
            comparison_years
          )
        )
        for (y in seq_along(comparison_years)) {
          seek(
            zz,
            where = (comparison_years[y] - tmp_header$header["firstyear"]) *
              prod(tmp_header$header[c("ncell", "nbands")]) *
              get_datatype(tmp_header)$size + get_headersize(tmp_header)
          )
          cmp_data[, , y] <- matrix(
            readBin(
              zz,
              what = get_datatype(tmp_header)$type,
              size = get_datatype(tmp_header)$size,
              n = tmp_header$header["ncell"] * tmp_header$header["nbands"],
              endian = tmp_header$endian
            ) * tmp_header$header["scalar"],
            ncol = tmp_header$header["nbands"],
            byrow = tmp_header$header["order"] != 4
          )
        }
        if (!ud.are.convertible(version_unit[version], "m2")) {
          # Assume fractional and convert into area
          cmp_data <- ud.convert(cmp_data, version_unit[version], 1) *
            cft_gridarea[[resol]]
          # Data is now in m2.
        }
        varname <- paste0("fallowdata_", resol)
        if(nchar(version_string[version]) > 0) {
          varname <- paste0(varname, "_", version_string[version])
        }
        assign(varname, cmp_data)
        close(zz)
      } else if (version != "harvested") {
        warning(cft_output_filename, " does not exist.", call. = FALSE,
                immediate. = TRUE)
      }
    } else {
      warning(cft_output_filename, " does not exist.", call. = FALSE,
              immediate. = TRUE)
    }
  }
}
# Reset version_unit if it is fractional because fractions have been converted
# to m2.
for (i in seq_along(version_unit)) {
  if (!ud.are.convertible(version_unit, "m2"))
    version_unit[i] <- "m2"
}

## ISIMIP2b landuse dataset                                                   ##
cat("Load ISIMIP2b comparison data from", lufilename_isimip, "\n")
luheader_isimip <- read_header(lufilename_isimip)
if (length(cft_bands) != luheader_isimip$header["nbands"]) {
  stop("Wrong number of bands in ", sQuote(lufilename_isimip))
}
zz <- file(lufilename_isimip, "rb")
ludata_isimip <- array(
  dim = c(
    luheader_isimip$header[c("ncell", "nbands")],
    length(comparison_years)
  ),
  dimnames = list(NULL, cft_bands, comparison_years)
)
for (y in seq_along(comparison_years)) {
  seek(
    zz,
    where = (comparison_years[y] - luheader_isimip$header["firstyear"]) *
      prod(luheader_isimip$header[c("nbands", "ncell")]) *
      get_datatype(luheader_isimip)$size + get_headersize(luheader_isimip)
  )
  ludata_isimip[, , y] <- matrix(
    readBin(
      zz,
      what = get_datatype(luheader_isimip)$type,
      size = get_datatype(luheader_isimip)$size,
      n = prod(luheader_isimip$header[c("nbands", "ncell")])
    ) * luheader_isimip$header["scalar"],
    ncol = luheader_isimip$header["nbands"],
    byrow = luheader_isimip$header["order"] != 4
  )
}
if (!ud.are.convertible(luunit_isimip, "m2")) {
  tmp_res <- unique(
    ifelse(
      luheader_isimip$header[c("cellsize_lon", "cellsize_lat")] >= 1/60, 60, 3600
    ) * luheader_isimip$header[c("cellsize_lon", "cellsize_lat")]
  )
  tmp_string <- paste(
    round(tmp_res),
    unique(
      ifelse(
        luheader_isimip$header[c("cellsize_lon", "cellsize_lat")] >= 1/60,
        "min",
        "sec"
      )
    ),
    sep = "", collapse = "_by_"
  )
  if (is.null(cft_gridarea[[tmp_string]]) || luheader_isimip$header["ncell"] != 
    cft_gridheader[[tmp_string]]$header["ncell"]) {
    stop("No matching grid for ISIMIP2b landuse data")
  }
  ludata_isimip <- ud.convert(ludata_isimip, luunit_isimip, "1") *
    cft_gridarea[[tmp_string]]
  luunit_isimip <- "m2"
}
close(zz)
################################################################################


################################################################################
## Aggregate data for tables                                                  ##
# Harvested areas. Use first version -> 5 arcmin by default.
ha_varname <- paste0("ludata_", names(cft_griddata))
names(ha_varname) <- names(cft_griddata)
if (nchar(version_string["harvested"]) > 0) {
  ha_varname <- paste0(ha_varname, "_", version_string["harvested"])
}
for (i in seq_along(ha_varname)) {
  if (exists(ha_varname[i])) {
    area_table <- data.frame(
      ha = ud.convert(
        apply(get(ha_varname[i]), c(2, 3), sum),
        version_unit["harvested"],
        comparison_unit
      )
    )
    break
  }
}
if (!exists("area_table")) {
  stop("No harvested area variable found")
}
# Add growing areas for all resolutions
for (resol in names(cft_griddata)) {
  varname <- paste0("ludata_", resol)
  if (nchar(version_string["default"]) > 0) {
    varname <- paste0(varname, "_", version_string["default"])
  }
  if (exists(varname)) {
    area_table <- cbind(
      area_table,
      ud.convert(apply(get(varname), c(2, 3), sum),
                 version_unit["default"], comparison_unit)
    )
    colnames(area_table)[seq(to = ncol(area_table), length.out = 2)] <- paste(
      varname, comparison_years,
      sep = "."
    )
  } else {
    area_table <- cbind(
      area_table,
      matrix(NA, ncol = length(comparison_years), nrow = 2,
             dimnames = list(NULL, paste(varname, comparison_years, sep = ".")))
    )
  }
}
# Add ISIMIP2b growing areas
area_table <- cbind(
  area_table,
  ludata_isimip = ud.convert(
    apply(ludata_isimip, c(2, 3), sum),
    luunit_isimip,
    comparison_unit
  )
)
rownames(area_table) <- cft_bands
area_table <- rbind(
  area_table,
  "rainfed crop sum" = apply(area_table[rf_crops, ], 2, sum),
  "irrigated crop sum" = apply(area_table[ir_crops, ], 2, sum),
  "total crop sum" = apply(area_table[c(rf_crops, ir_crops), ], 2, sum)
)
# Add fallow land
tmptable <- data.frame(
  matrix(NA, ncol = length(comparison_years), nrow = 2,
         dimnames = list(NULL, paste("ha", comparison_years, sep = ".")))
)
for (resol in names(cft_griddata)) {
  varname <- paste0("ludata_", resol)
  fallow_varname <- paste0("fallowdata_", resol)
  if (nchar(version_string["default"]) > 0) {
    varname <- paste0(varname, "_", version_string["default"])
    fallow_varname <- paste0(fallow_varname, "_", version_string["default"])
  }
  if (exists(fallow_varname)) {
    tmptable <- cbind(
      tmptable,
      ud.convert(apply(get(fallow_varname), c(2, 3), sum),
                 version_unit["default"], comparison_unit)
    )
    colnames(tmptable)[seq(to = ncol(tmptable), length.out = 2)] <- paste(
      varname, comparison_years,
      sep = "."
    )
  } else {
    tmptable <- cbind(
      tmptable,
      matrix(NA, ncol = length(comparison_years), nrow = 2,
             dimnames = list(NULL, paste(varname, comparison_years, sep = ".")))
    )
  }
}
tmptable <- cbind(
  tmptable,
  matrix(0, ncol = length(comparison_years), nrow = 2,
         dimnames = list(NULL, paste("ludata_isimip", comparison_years, sep=".")))
)
area_table <- rbind(area_table, tmptable)
rm(tmptable)
r <- grep("total crop sum|fallow", rownames(area_table))
area_table <- rbind(
  area_table,
  "total crops + fallow" = apply(area_table[r, ], 2, sum)
)

## Write area table to file in LaTeX table syntax for inclusion in manuscript ##
tmptable <- format(round(area_table))
tmptable <- sapply(tmptable, gsub, pattern="  NA", replacement = "n.a.")
rownames(tmptable) <- rownames(area_table)
write.table(
  tmptable,
  file = "paper_global_area_table.txt",
  sep = " & ", eol = " \\\\ \n", quote = FALSE,
  col.names = FALSE, row.names = format(rownames(tmptable))
)

irrigated_share_table <- area_table[grep("irrigated", rownames(area_table)), ] /
  (area_table[grep("rainfed", rownames(area_table)), ] +
  area_table[grep("irrigated", rownames(area_table)), ])

if (exists("trends_table"))
  rm(trends_table)
if (exists("trends_table_total"))
  rm(trends_table_total)
if (length(comparison_years) > 1) {
  for (i in seq(2, length(comparison_years))) {
    if (exists("trends_table")) {
      trends_table <- cbind(
        trends_table,
        area_table[, grep(comparison_years[i], colnames(area_table))] /
          area_table[, grep(comparison_years[i - 1], colnames(area_table))]
      )
      rows1 <- grep("rainfed", rownames(area_table))
      rows2 <- grep("irrigated", rownames(area_table))
      cols1 <- grep(comparison_years[i], colnames(area_table))
      cols2 <- grep(comparison_years[i - 1], colnames(area_table))
      trends_table_total <- cbind(
        trends_table_total,
        (area_table[rows1, cols1] + area_table[rows2, cols1]) /
          (area_table[rows1, cols2] + area_table[rows2, col2])
      )
    } else {
      trends_table <- area_table[, grep(comparison_years[i], colnames(area_table))] /
        area_table[, grep(comparison_years[i - 1], colnames(area_table))]
      rows1 <- grep("rainfed", rownames(area_table))
      rows2 <- grep("irrigated", rownames(area_table))
      cols1 <- grep(comparison_years[i], colnames(area_table))
      cols2 <- grep(comparison_years[i - 1], colnames(area_table))
      trends_table_total <-
        (area_table[rows1, cols1] + area_table[rows2, cols1]) /
        (area_table[rows1, cols2] + area_table[rows2, cols2])
    }
  }
}
## crop ranking in terms of irrigation share
crop_rank <- list()
r <- grep("sum|fallow", rownames(irrigated_share_table), invert = TRUE)
n <- rownames(irrigated_share_table)[r]
for (i in seq_along(comparison_years)) {
  for (col in grep(
    comparison_years[i], colnames(irrigated_share_table), value = TRUE)
  ) {
    if (is.null(crop_rank[[as.character(comparison_years[i])]])) {
      crop_rank[[as.character(comparison_years[i])]] <- matrix(
        n[order(irrigated_share_table[r, col], decreasing = TRUE)],
        ncol = 1, dimnames = list(NULL, col)
      )
    } else {
      crop_rank[[as.character(comparison_years[i])]] <- cbind(
        crop_rank[[as.character(comparison_years[i])]],
        matrix(
          n[order(irrigated_share_table[r, col], decreasing = TRUE)],
          ncol = 1, dimnames = list(NULL, col)
        )
      )
    }
  }
}
################################################################################


################################################################################
## Load data for global time series plot                                      ##
load(ha_country_timeseries_RData)
# hard-coded: countries without country groups -> confirm if data change!
c_index <- seq(1, 256)
timeseries_table_ha <- data.frame(
  total_ha = ud.convert(
    apply(get(total_version_to_use)[c_index, ts_crops, ], 3, sum, na.rm = TRUE),
    fao_area_units, comparison_unit
  ),
  total_gapfilled = ud.convert(
    apply(
      (get(total_version_to_use)[c_index, ts_crops, ] *
        get(paste0(total_version_to_use, "_gapfilling"))[c_index, ts_crops, ]),
      3, sum, na.rm = TRUE
    ),
    fao_area_units, comparison_unit
  ),
  irrigated_ha = ud.convert(
    apply(get(irrigated_version_to_use)[c_index, ts_crops, ],
          3, sum, na.rm = TRUE),
    fao_area_units, comparison_unit
  ),
  irrigated_gapfilled = ud.convert(
    apply(
      (get(irrigated_version_to_use)[c_index, ts_crops, ] *
        get(paste0(irrigated_version_to_use, "_gapfilling"))[c_index, ts_crops, ]),
      3, sum, na.rm = TRUE
    ),
    fao_area_units, comparison_unit
  )
)
timeseries_table_ha <- cbind(
  timeseries_table_ha,
  rainfed_ha = timeseries_table_ha$total_ha - timeseries_table_ha$irrigated_ha,
  rainfed_gapfilled = apply(
    ((get(total_version_to_use) - pmax(get(irrigated_version_to_use), 0, na.rm = TRUE)) *
      (get(paste0(total_version_to_use, "_gapfilling")) |
        get(paste0(irrigated_version_to_use, "_gapfilling")))
    )[c_index, ts_crops, ],
    3, sum, na.rm = TRUE
  ) * ud.convert(1, fao_area_units, comparison_unit)
)
## Note: timeseries_table_ha$rainfed_gapfilled not reasonable to interpret    ##

cropland_timeseries <- ud.convert(
  apply(
    (hyde_cropland_country_timeseries[c_index, ] * apply(
      get(total_version_to_use)[c_index, ts_crops, ],
      c(1,3),
      function(indata) any(!is.na(indata))
    )),
    2,
    sum
  ),
  fao_area_units, comparison_unit
)
irrigated_timeseries <- ud.convert(
  apply(
    (hyde_irrigated_country_timeseries[c_index, ] * apply(
      get(irrigated_version_to_use)[c_index, ts_crops, ],
      c(1,3),
      function(indata) any(!is.na(indata))
    )),
    2,
    sum
  ),
  fao_area_units, comparison_unit
)
plot_xlim <- range(as.integer(names(cropland_timeseries))) + c(-1, 1)
plot_ylim <- c(0, max(c(cropland_timeseries, timeseries_table_ha$total_ha)))
plot_coords <- function(plotdata, n = names(plotdata)) {
  total_plot_vals <- c(rep(0, length(plotdata)), rev(plotdata))
  total_plot_x <- c(as.integer(n),
                    rev(as.integer(n)))
  return(cbind(total_plot_x, total_plot_vals))
}
pdf(
  file = paste0(
    "paper_global_cropland_harvested_area_timeseries",
    file_version_string,
    ".pdf"
  ),
  width = 5.5,
  height = 2.5,
  pointsize = 8
)
par(mar = c(2, 3, 0, 0) + 0.1)
plot(1, 1, type = "n", xlim = plot_xlim, ylim = plot_ylim, xlab = "", ylab = "",
     main = "", yaxt = "n", xaxs = "i")
axis(2, at = pretty(plot_ylim), labels = pretty(plot_ylim) * 1e-6,
     mgp = c(2, 0.75, 0))
#title(ylab = expression(paste("Global area [", 10^6, km^2, "]")),
#      mgp = c(1.75,1,0))
# Note: The following may not create a y-axis label that is properly formatted
# unless comparison_unit is one of "ha", "m2" or "km2".
title(
  ylab = switch(
    comparison_unit,
    ha = expression(paste("Global area [", 10^6 ~ ha, "]")),
    m2 = expression(paste("Global area [", 10^6 ~ m^2, "]")),
    km2 = expression(paste("Global area [", 10^6 ~ km^2, "]")),
    substitute(paste("Global area [", 10^6 ~ au, "]"), list(au = comparison_unit))
  ),
  mgp = c(1.75,1,0)
)
# total cropland
xy <- plot_coords(cropland_timeseries)
polygon(x = xy[, "total_plot_x"], y = xy[, "total_plot_vals"], density = NA,
        col = "sandybrown", border = NA)
# total harvested areas
xy <- plot_coords(timeseries_table_ha$total_ha, rownames(timeseries_table_ha))
polygon(x = xy[, "total_plot_x"], y = xy[, "total_plot_vals"], density = NA,
        col = "seagreen1", border = NA)
# irrigated harvested areas
xy <- plot_coords(timeseries_table_ha$irrigated_ha, rownames(timeseries_table_ha))
polygon(x = xy[, "total_plot_x"], y = xy[, "total_plot_vals"], density = NA,
        col = "steelblue1", border = NA)
#irrigated cropland
xy <- plot_coords(irrigated_timeseries)
polygon(x = xy[, "total_plot_x"], y = xy[, "total_plot_vals"], density = NA,
        col = "royalblue", border = NA)
# gapfilled total ha
lines(
  x = as.integer(rownames(timeseries_table_ha)),
  y = timeseries_table_ha$total_gapfilled,
  col = "seagreen", lty = 2, lwd = 0.75
)
# gapfilled irrigated ha
lines(
  x = rownames(timeseries_table_ha),
  y = timeseries_table_ha$irrigated_gapfilled,
  col = "steelblue", lty = 2, lwd = 0.75
)

lines(
  x = as.integer(rownames(timeseries_table_ha)),
  y = timeseries_table_ha$total_ha,
  type = "l", lwd = 1, col = "seagreen"
)
lines(
  x = as.integer(rownames(timeseries_table_ha)),
  y = timeseries_table_ha$irrigated_ha,
  type = "l", lwd = 1, col = "steelblue"
)

legend(
  "topleft",
  legend = c("total cropland", "irrigated cropland", "total harvested area",
             "irrigated harvested area", "gap-filled total harvested area",
             "gap-filled irrigated harvested area"),
  fill = c("sandybrown", "royalblue", "seagreen1", "steelblue1", NA, NA),
  lty = c(rep(NA, 4), 2, 2),
  lwd = c(rep(NA, 4), 0.75, 0.75),
  pch = NA,
  col = c(rep(NA, 4), "seagreen", "steelblue"),
  border=c(NA, NA, "seagreen", "steelblue", NA, NA, NA)
)
dev.off()
################################################################################


################################################################################
## Load redistribution statistics to extract example                          ##
# Set start_year and end_year of a period processed using
# harvested_area_timeseries.R
start_year <- 2000
end_year <- 2017
# Optional path to remote files if not run on local machine
redist_stats_file <- file.path(
  working_dir,
  paste0(
    "harvested_area_GADM_timeseries_",
    start_year, "-", end_year,
    "_redistribution_stats",
    file_version_string,
    ".RData"
  )
)
load(redist_stats_file)
# Write example table for Burkina Faso in 2015 to file in LaTeX table syntax.
tmptable <- format(
  cbind(
    round(redist_stats[["2015"]][["Burkina Faso"]][, -11]),
    redist_stats[["2015"]][["Burkina Faso"]][, 11]
  )
)
tmptable <- sapply(tmptable, gsub, pattern ="NA", replacement = "--")
rownames(tmptable) <- rownames(redist_stats[["2015"]][["Burkina Faso"]])
write.table(
  tmptable,
  file = "paper_example_redist_stats.txt",
  sep = " & ", eol = " \\\\ \n", quote = FALSE,
  col.names = FALSE, row.names = format(rownames(tmptable))
)
################################################################################
